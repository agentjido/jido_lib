%{
  status: :generated,
  title: "Jido Documentation Writer Smoke Test",
  repos: [],
  prompt_overrides: %{
  required_sections: ["Overview", "Setup", "Run the pipeline",
   "Troubleshooting"],
  must_include: ["A complete runnable example",
   "A brief explanation of expected output"],
  must_avoid: ["TODO placeholders"]
},
  audience: "developer",
  ecosystem_packages: ["jido", "jido_action", "jido_signal", "kino"],
  grounding_run_id: "151afecb1f73",
  last_grounded_at: "2026-02-28T21:37:19.221502Z",
  source_files: ["lib/jido_lib/github/agents/documentation_writer_bot.ex",
 "lib/jido_lib/github/actions/docs_writer/run_writer_pass.ex"],
  destination_route: "docs/smoke/jido-doc-writer",
  destination_collection: :pages
}
---
%{
  title: "Jido Documentation Writer Smoke Test",
  description: "A concise description of this guide.",
  category: :docs,
  order: 10,
  tags: [:docs, :learn]
}
---
# Jido Documentation Writer Smoke Test

This Livebook walks through a smoke test of the Jido documentation writer pipeline. We'll run the writer/critic workflow from a brief, verify that it produces a draft artifact, and understand what a successful run should look like. The goal is to give you a repeatable, minimal path to confirm the pipeline works end-to-end.

## Prerequisites

You should have access to a repo checkout of `agentjido/jido_lib`, a working Elixir toolchain, and valid credentials for any required providers. If you are already running Jido workflows, this should feel familiar.

## Setup

```elixir
Mix.install([{:jido, "~> 2.0"}, {:jido_action, "~> 2.0"}, {:jido_signal, "~> 2.0"}, {:kino, "~> 0.14"}])
```

## Defining Actions

Actions receive `params` (validated inputs) and `context` (includes `context.state`
with the current agent state). Return `{:ok, %{field: new_value}}` with the NEW values
computed from current state.

```elixir
defmodule Increment do
  use Jido.Action,
    name: "increment",
    schema: [amount: [type: :integer, default: 1]]

  @impl true
  def run(params, context) do
    current = context.state.count
    {:ok, %{count: current + params.amount}}
  end
end
```

CRITICAL: Actions access current state via `context.state`, NOT `params`.
The return map `%{count: new_value}` is merged into the agent's state.

## Defining the Agent Module

The docs writer pipeline is packaged as an agent with a workflow DAG. This example agent is a minimal stand-in to show the Jido API pattern used by the pipeline. The pipeline itself is implemented in `Jido.Lib.Github.Agents.DocumentationWriterBot`.

```elixir
defmodule MyApp.Example do
  use Jido.Agent,
    name: "example",
    schema: [
      count: [type: :integer, default: 0]
    ]
end
```

## Running Commands

Demonstrate the API with concrete examples. Define variables BEFORE using them.
CRITICAL: `use Jido.Agent` generates new/0, cmd/2, set/2 on YOUR module.
Call `YourModule.new()` — NOT `Jido.Agent.new(YourModule)`.
`cmd/2` returns `{agent, directives}` — a 2-tuple, NOT `{:ok, agent, directives}`.

```elixir
# Create agent via the module's own new/0 (generated by `use Jido.Agent`)
agent = MyApp.Example.new()
# Run commands via the module's own cmd/2 — returns {agent, directives} 2-tuple
{updated, _directives} = MyApp.Example.cmd(agent, [Increment])
IO.inspect(updated.state, label: "State after command")
```

## Testing

```elixir
ExUnit.start(autorun: false)

defmodule MyApp.ExampleTest do
  use ExUnit.Case

  test "state transitions" do
    agent = MyApp.Example.new()
    assert agent.state.count == 0
  end
end

ExUnit.run()
```

## Overview

The documentation writer pipeline is a Jido agent that runs a multi-step workflow with writer and critic passes, optional revision, and final publishing. The workflow is defined in `Jido.Lib.Github.Agents.DocumentationWriterBot.build_workflow/0` and the primary entrypoint is `Jido.Lib.Github.Agents.DocumentationWriterBot.run_brief/2`.

At a high level, the pipeline:
- Parses the content brief and resolves the output path.
- Prepares the runtime and role environments.
- Runs writer and critic passes (with optional revision).
- Evaluates the Livebook draft and finalizes the guide.
- Publishes a PR if requested.

## Setup

The pipeline needs a content brief and run options. The brief is plain text that includes the frontmatter template and required sections. Options control provider selection, publish behavior, and output locations.

The key options used in this smoke test are:
- `run_id`: stable identifier for prompt files and artifacts.
- `output_repo`: repository slug for the target output repo.
- `output_path`: where the Livebook will be written.
- `writer_provider` and `critic_provider`: LLM backends.
- `single_pass`: when `true`, only the first writer/critic pass is used.
- `publish`: whether to open a PR with the result.

## Run the pipeline

The example below runs the pipeline from a brief and returns a result map. This is a full, runnable smoke test. It sets the `run_id`, output location, providers, and publish behavior. It also includes an explicit `content_metadata` section with the title and ecosystem packages used in the guide.

```elixir
alias Jido.Lib.Github.Agents.DocumentationWriterBot

brief = """
# Jido Documentation Writer Smoke Test

Write a practical guide that shows how to run the documentation writer pipeline and verify the final output.
"""

opts = [
  run_id: "151afecb1f73",
  output_repo: "agentjido/jido_lib",
  output_path: "priv/pages/docs/smoke/jido-doc-writer.livemd",
  writer_provider: :codex,
  critic_provider: :claude,
  single_pass: false,
  publish: true,
  content_metadata: %{
    title: "Jido Documentation Writer Smoke Test",
    ecosystem_packages: ["jido", "jido_action", "jido_signal", "kino"]
  }
]

result = DocumentationWriterBot.run_brief(brief, opts)
IO.inspect(result, label: "Docs writer result")
```

### Expected output

A successful run returns a map with `:status` set to `:completed` and includes the resolved `:run_id`. If the run completes and publishing is requested, the workflow will prepare the final Livebook and submit a PR to the output repository. If the pipeline fails partway through, the map will include `:error` and partial results that help pinpoint where the failure occurred.

## Troubleshooting

Common failure modes and how to resolve them:

- `{:provider_runtime_not_ready, provider}`: The writer or critic runtime was not prepared. Ensure the runtime setup actions ran and the provider is correctly configured.
- `{:docs_run_writer_pass_failed, :invalid_iteration}`: A writer pass was invoked with an invalid iteration. Writer passes must be `1` or `2`.
- `{:docs_run_writer_pass_failed, reason}`: A writer pass failed. Check provider credentials, runtime logs, and the prompt file path under `.jido/prompts/` for the given `run_id`.
- Missing output file: Confirm `output_path` points to a valid location in the output repo and that `publish: true` is set if you expect a PR.

## What to Try Next

If you want to expand beyond this smoke test, consider:
- Adding a custom `prompt_overrides` map to tailor the writer/critic instructions.
- Running with `single_pass: true` to skip revision logic.
- Adjusting `timeout` and `await_timeout` for longer guides.

```elixir
# CRITICAL: Assign the final module to DemoAgent for the visualizer
DemoAgent = MyApp.Example
```

## Try It Live -- Interactive Demo

*This interactive simulator was autonomously generated and compiler-verified by the Jido Documentation Pipeline on 2026-02-28 (Run ID: 151afecb1f73).*

```elixir
defmodule Increment do
  use Jido.Action,
    name: "increment",
    schema: [amount: [type: :integer, default: 1]]

  @impl true
  def run(params, context) do
    current = context.state.count
    {:ok, %{count: current + params.amount}}
  end
end

defmodule MyApp.Example do
  use Jido.Agent,
    name: "example",
    schema: [
      count: [type: :integer, default: 0]
    ]
end

# Create agent via the module's own new/0 (generated by `use Jido.Agent`)
agent = MyApp.Example.new()
# Run commands via the module's own cmd/2 — returns {agent, directives} 2-tuple
{updated, _directives} = MyApp.Example.cmd(agent, [Increment])
IO.inspect(updated.state, label: "State after command")

alias Jido.Lib.Github.Agents.DocumentationWriterBot

brief = """
# Jido Documentation Writer Smoke Test

Write a practical guide that shows how to run the documentation writer pipeline and verify the final output.
"""

opts = [
  run_id: "151afecb1f73",
  output_repo: "agentjido/jido_lib",
  output_path: "priv/pages/docs/smoke/jido-doc-writer.livemd",
  writer_provider: :codex,
  critic_provider: :claude,
  single_pass: false,
  publish: true,
  content_metadata: %{
    title: "Jido Documentation Writer Smoke Test",
    ecosystem_packages: ["jido", "jido_action", "jido_signal", "kino"]
  }
]

result = DocumentationWriterBot.run_brief(brief, opts)
IO.inspect(result, label: "Docs writer result")

DemoAgent = MyApp.Example

# Mount the Interactive Viewer
if binding()[:DemoAgent] do
  Kino.Jido.agent_viewer(DemoAgent)
else
  Kino.Markdown.new("**Notice:** The tutorial did not export a `DemoAgent` module to visualize.")
end
```

<!--
PROVENANCE:
Generated by Jido Documentation Writer Bot | Run ID: `151afecb1f73`
Target: Livebook (.livemd)
-->
