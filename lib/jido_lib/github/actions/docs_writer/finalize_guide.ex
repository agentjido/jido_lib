defmodule Jido.Lib.Github.Actions.DocsWriter.FinalizeGuide do
  @moduledoc """
  Finalizes docs output and persists guide/manifest artifacts.
  """

  use Jido.Action,
    name: "docs_writer_finalize_guide",
    description: "Finalize docs writer outputs",
    compensation: [max_retries: 0],
    schema: [
      run_id: [type: :string, required: true],
      owner: [type: :string, required: true],
      repo: [type: :string, required: true],
      output_repo_context: [type: {:or, [:map, nil]}, default: nil],
      output_path: [type: {:or, [:string, nil]}, default: nil],
      publish: [type: :boolean, default: false],
      content_metadata: [type: {:or, [:map, nil]}, default: nil],
      embedded_draft: [type: {:or, [:string, nil]}, default: nil],
      writer_provider: [type: :atom, required: true],
      critic_provider: [type: :atom, required: true],
      max_revisions: [type: :integer, default: 1],
      single_pass: [type: :boolean, default: false],
      writer_draft_v1: [type: {:or, [:string, nil]}, default: nil],
      writer_draft_v2: [type: {:or, [:string, nil]}, default: nil],
      critique_v1: [type: {:or, [:map, nil]}, default: nil],
      critique_v2: [type: {:or, [:map, nil]}, default: nil],
      gate_v1: [type: {:or, [:map, nil]}, default: nil],
      gate_v2: [type: {:or, [:map, nil]}, default: nil],
      final_decision: [type: {:or, [:atom, nil]}, default: nil],
      needs_revision: [type: {:or, [:boolean, nil]}, default: nil],
      iterations_used: [type: {:or, [:integer, nil]}, default: nil],
      artifacts: [type: {:or, [:map, nil]}, default: nil],
      started_at: [type: {:or, [:string, nil]}, default: nil],
      repo_dir: [type: {:or, [:string, nil]}, default: nil],
      workspace_dir: [type: {:or, [:string, nil]}, default: nil],
      session_id: [type: {:or, [:string, nil]}, default: nil],
      sprite_name: [type: {:or, [:string, nil]}, default: nil],
      sprite_config: [type: {:or, [:map, nil]}, default: nil],
      sprites_mod: [type: :atom, default: Sprites]
    ]

  alias Jido.Lib.Bots.Foundation.ArtifactStore
  alias Jido.Lib.Github.Actions.DocsWriter.Helpers

  @impl true
  def run(params, _context) do
    decision = params[:final_decision] || infer_decision(params)
    original_metadata = params[:content_metadata] || %{}
    final_guide = build_final_guide(params, decision, original_metadata)
    iterations_used = infer_iterations(params)

    with {:ok, store} <- Helpers.artifact_store(params),
         {:ok, final_guide_artifact} <-
           ArtifactStore.write_text(store, "final_guide.md", final_guide),
         {:ok, manifest_artifact} <-
           write_manifest(store, params, decision, iterations_used, final_guide_artifact) do
      artifacts =
        params
        |> Map.get(:artifacts)
        |> case do
          map when is_map(map) -> map
          _ -> %{}
        end
        |> Map.put(:final_guide, final_guide_artifact)
        |> Map.put(:manifest, manifest_artifact)

      {:ok,
       Helpers.pass_through(params)
       |> Map.put(:final_decision, decision)
       |> Map.put(:decision, decision)
       |> Map.put(:iterations_used, iterations_used)
       |> Map.put(:final_guide, final_guide)
       |> Map.put(:publish_requested, params.publish == true)
       |> Map.put(:published, false)
       |> Map.put(:artifacts, artifacts)
       |> Map.put(:status, status_from_decision(decision))}
    else
      {:error, reason} ->
        {:error, {:docs_finalize_guide_failed, reason}}
    end
  end

  defp write_manifest(store, params, decision, iterations_used, final_guide_artifact) do
    output_repo =
      case params[:output_repo_context] do
        %{} = context -> context.slug
        _ -> "#{params.owner}/#{params.repo}"
      end

    manifest = %{
      run_id: params.run_id,
      bot: "documentation_writer",
      status: status_from_decision(decision),
      started_at: params[:started_at] || Helpers.now_iso8601(),
      finished_at: Helpers.now_iso8601(),
      output_repo: output_repo,
      output_path: params[:output_path],
      providers: %{
        writer: params.writer_provider,
        critic: params.critic_provider
      },
      max_revisions: params.max_revisions,
      iterations_used: iterations_used,
      decision: decision,
      publish_requested: params.publish == true,
      artifacts: Map.put(params[:artifacts] || %{}, :final_guide, final_guide_artifact),
      gate: %{
        v1: params[:gate_v1],
        v2: params[:gate_v2]
      }
    }

    ArtifactStore.write_json(store, "manifest.json", manifest)
  end

  defp build_final_guide(params, :rejected, _metadata) do
    critique = params[:critique_v2] || params[:critique_v1] || %{}
    instructions = critique[:revision_instructions] || critique["revision_instructions"] || ""

    """
    <!-- PROVENANCE FAILURE: Generated by Jido Documentation Writer Bot | Run ID: `#{params.run_id}` -->
    # Documentation Guide Generation Failed

    The writer/critic workflow did not reach an accepted guide within the revision budget.

    Last critique guidance:

    #{instructions}
    """
    |> String.trim()
  end

  defp build_final_guide(params, _decision, metadata) do
    # Prefer embedded_draft (which includes the interactive demo) over raw drafts
    draft =
      params[:embedded_draft] || params[:writer_draft_v2] || params[:writer_draft_v1] ||
        "No guide draft was generated."

    # Strip any wrapping markdown fences the LLM may have added
    clean_draft =
      case Regex.run(~r/\A```(?:markdown|livemd)?\s*([\s\S]*?)\s*```\z/, String.trim(draft)) do
        [_, inner] -> String.trim(inner)
        _ -> String.trim(draft)
      end

    # Re-inject updated frontmatter with provenance
    fm_string = build_frontmatter(metadata, params.run_id)

    """
    #{fm_string}#{clean_draft}

    <!--
    PROVENANCE:
    Generated by Jido Documentation Writer Bot | Run ID: `#{params.run_id}`
    Target: Livebook (.livemd)
    -->
    """
    |> String.trim()
  end

  defp build_frontmatter(metadata, run_id) when map_size(metadata) == 0 do
    "<!-- Generated by Jido Documentation Writer Bot | Run ID: `#{run_id}` -->\n"
  end

  defp build_frontmatter(metadata, run_id) do
    updated_metadata =
      metadata
      |> Map.put(:status, :generated)
      |> Map.put(:last_grounded_at, Helpers.now_iso8601())
      |> Map.put(:grounding_run_id, run_id)

    fm_entries =
      Enum.map_join(updated_metadata, ",\n", fn {k, v} ->
        "  #{k}: #{inspect(v, pretty: true)}"
      end)

    "%{\n#{fm_entries}\n}\n---\n"
  end

  defp infer_decision(params) do
    cond do
      is_map(params[:gate_v2]) and is_atom(params.gate_v2[:decision]) -> params.gate_v2[:decision]
      is_map(params[:gate_v1]) and is_atom(params.gate_v1[:decision]) -> params.gate_v1[:decision]
      params[:needs_revision] == true -> :rejected
      true -> :failed
    end
  end

  defp infer_iterations(params) do
    cond do
      is_binary(params[:writer_draft_v2]) and params.writer_draft_v2 != "" -> 2
      is_integer(params[:iterations_used]) -> params.iterations_used
      true -> 1
    end
  end

  defp status_from_decision(decision) when decision in [:accepted, :revised], do: :completed
  defp status_from_decision(:rejected), do: :failed
  defp status_from_decision(:failed), do: :error
  defp status_from_decision(_), do: :error
end
